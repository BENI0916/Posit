2025/01/13
	Posit_fabs.cpp:
		input: x
		output: abs(x)
	
	__kernel_tan.cpp:
		one: 常數 1
		pio4: pi / 4
		pio4lo: pi / 4 的低位補償值
		
		T[]: 為tan(x)的泰勒展開式的係數
		
		(x, y, iy):
			x: 主要輸入值
			y: 補償值
			iy: 1 or -1，-1是計算倒數。
		
		fabs_x: x的絕對值
		hx: x的高位
		
		|x| < limit1:
			x很小的情況，且x趨近於0時。
			low: x的低位。
			若x == 0 且 iy == -1，回傳 one / fabs_x，表示無窮大。
			(這裡的x為0是真的0，不是(int)x == 0。)
			
			else
				 if(iy == 1)
				 	return x;
				 else
				 	/* 處理倒數（cotangent）情況 */
					Posit64 a, t;
					z = w = x + y; // x 和補償值 y 的和
					SET_LOW_WORD(z, 0); // 清除低位
					v = y - (z - x); // 精度補償
					t = a = -one / w; // 倒數初值
					SET_LOW_WORD(t, 0); // 清除低位誤差
					s = one + t * z; // 誤差修正
					return t + a * (s + t * v); // 最終結果
		
		|x| >= limit2:
			如果 |x| 大於 0.6744，會先將 xx 歸一化到小範圍內（靠近 pi / 4）。
			使用補償值（pio4lo）確保高精度。
			
			接著再做多項式的展開計算。
		
		最後再做輸出的修正，若要輸出倒數，則額外處理。
	
	test2.cpp:
		測試 __kernel_tan.cpp
		compile:　g++ -std=c++17 -o test2 test2.cpp __kernel_tan.cpp Posit_fabs.cpp
	
	Posit_rempio2.cpp:
		input floating number x
		將x簡化為區間[0, pi / 2] or [-pi / 2, 0]的範圍內。
		接著若x簡化完後位於[-pi / 2, 0]，則再加一次 pi / 2，而 n ++ 。
		回傳整數 n ，表示 x 減了或加了 n 次的 pi / 2。
		y[0]存放做完計算的x。
	
	test3.cpp:
		測試Posit_rempio2.cpp
		compile: g++ -std=c++17 -o test3 test3.cpp Posit_rempio2.cpp
		
	Posit_cos.cpp:
		input x
		
		if |x| < pi / 4:
			return __kernel_cos(x, 0);
			
		else if x == NAR:
			cos(INF or NAN) is NAN
			return x - x;
		
		else
			use rempio2, get n
			用n做條件判斷
	
	test4.cpp:
		測試 Posit_cos.cpp
		compile: g++ -std=c++17 -o test4 test4.cpp Posit_cos.cpp __kernel_cos.cpp __kernel_sin.cpp Posit_rempio2.cpp Posit_fabs.cpp
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
				
